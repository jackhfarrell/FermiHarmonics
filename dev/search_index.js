var documenterSearchIndex = {"docs":
[{"location":"api/source_terms/#Source-Terms","page":"Source Terms","title":"Source Terms","text":"","category":"section"},{"location":"api/source_terms/#Combined-Source-Terms","page":"Source Terms","title":"Combined Source Terms","text":"","category":"section"},{"location":"api/source_terms/#Physical-Source-Terms","page":"Source Terms","title":"Physical Source Terms","text":"","category":"section"},{"location":"api/source_terms/#FermiHarmonics.source_terms","page":"Source Terms","title":"FermiHarmonics.source_terms","text":"source_terms(u, x, t, equations) -> SVector\n\nCompute physical scattering source terms.\n\n\n\n\n\n","category":"function"},{"location":"api/source_terms/#FermiHarmonics.physical_sources","page":"Source Terms","title":"FermiHarmonics.physical_sources","text":"physical_sources(u, x, t, equations) -> SVector\n\nSource terms from a BGK-type approximation to the collision integral.  We do not damp  a_0 (density). The momentum modes a_1 b_1 are damped at the momentum-relaxing rate  gamma_mr, while higher harmonics are damped at the full scattering rate  gamma_mr + gamma_mc.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Mesh","page":"Mesh","title":"Mesh","text":"This project expects 2D quad meshes in Abaqus .inp format (loaded with Trixi.P4estMesh{2}).\n\nWorkflow:\n\nDefine geometry + physical boundary names in a .geo file.\nForce quad meshing in Gmsh.\nExport to .inp.\nUse those same names in your Julia boundary_conditions dictionary.","category":"section"},{"location":"mesh/#Quad-Requirement-(Important)","page":"Mesh","title":"Quad Requirement (Important)","text":"Do not generate triangle-only meshes.\n\nIn your .geo, force recombination to quads, e.g.\n\nMesh.RecombineAll = 1;\nRecombine Surface {1};\n\nOptional (often helpful for quads):\n\nMesh.Algorithm = 8; // Frontal-Delaunay for quads","category":"section"},{"location":"mesh/#Boundary-Naming","page":"Mesh","title":"Boundary Naming","text":"There is no single required set of boundary names at the package level. Use whatever physical names fit your geometry, as long as:\n\nthey are defined as Physical Curve(\"...\") in Gmsh, and\nthe same names are used as keys in your Julia boundary_conditions.\n\nFor the square-bells example, the names are walls, contact_top, and contact_bottom:\n\nPhysical Surface(\"domain\") = {1};\nPhysical Curve(\"contact_bottom\") = {1};\nPhysical Curve(\"contact_top\") = {11};\nPhysical Curve(\"walls\") = {2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n\nReference file:\n\nprojects/square_bells_ucsb/mesh/square_bells.geo","category":"section"},{"location":"mesh/#Build-.inp-From-.geo-With-Gmsh","page":"Mesh","title":"Build .inp From .geo With Gmsh","text":"From repository root (quad-focused command):\n\ngmsh -2 projects/square_bells_ucsb/mesh/square_bells.geo \\\n  -string \"Mesh.RecombineAll=1;\" \\\n  -format inp \\\n  -o projects/square_bells_ucsb/mesh/square_bells.inp","category":"section"},{"location":"mesh/#Map-Mesh-Boundaries-To-Boundary-Conditions","page":"Mesh","title":"Map Mesh Boundaries To Boundary Conditions","text":"Boundary-condition keys must match physical curve names in the mesh:\n\nusing FermiHarmonics\nusing Trixi\n\nboundary_conditions = Dict(\n    :walls => MaxwellWallBC(1.0),\n    :contact_top => OhmicContactBC(-0.5),\n    :contact_bottom => OhmicContactBC(0.5),\n)\n\nparams = SolveParams()\n\nsol, semi = solve(\n    \"projects/square_bells_ucsb/mesh/square_bells.inp\",\n    boundary_conditions,\n    params,\n    0.0,   # gamma_mr\n    50.0;  # gamma_mc\n    max_harmonic = :auto,\n)\n\nIf names do not match, boundary assignment fails.","category":"section"},{"location":"mesh/#Notes","page":"Mesh","title":"Notes","text":"Keep physical names stable once sweeps start.\nWhen running on SLURM, this project copies the mesh to node-local scratch to avoid parallel file-system races.","category":"section"},{"location":"mesh/#TODO","page":"Mesh","title":"TODO","text":"Add a Julia-side mesh generation helper so .geo -> .inp can be called directly from Julia scripts (instead of shelling out to gmsh manually).","category":"section"},{"location":"api/solve/#Solve:-main-entry-point","page":"Solve","title":"Solve: main entry point","text":"","category":"section"},{"location":"api/solve/#Script-Style-Usage","page":"Solve","title":"Script-Style Usage","text":"params = SolveParams(;\n    max_harmonic = 60,   # optional fixed cap if you call solve(...; max_harmonic=params.max_harmonic)\n    polydeg = 3,\n    cfl = 0.2,\n    tspan_end = 50.0,\n    residual_tol = 1e-8,\n    log_every = 50,\n)\n\nboundary_conditions = Dict(\n    :walls => MaxwellWallBC(1.0),\n    :source => OhmicContactBC(0.5),\n    :drain => OhmicContactBC(-0.5),\n)\n\nsol, semi = solve(\n    \"mesh.inp\",\n    boundary_conditions,\n    params,\n    0.05,  # gamma_mr\n    0.40;  # gamma_mc\n    max_harmonic = :auto,\n    visualize = false,\n    name = \"case_001\",\n)","category":"section"},{"location":"api/solve/#Behavior-Notes","page":"Solve","title":"Behavior Notes","text":"solve requires a SolveParams instance for solver settings.\nHarmonic count is fixed per solve (nvars = 1 + 2M), but M can be selected automatically per case via max_harmonic=:auto.\nAuto mode uses estimate_max_harmonic(gamma_mr, gamma_mc) with gamma_total = gamma_mr + gamma_mc.\nDefault logarithmic map is gamma_total=0 -> M=100 and gamma_total>=300 -> M=4.\nOptional tuning keys in SolveParams are min_harmonic and max_harmonic_auto.\nWarm starts via u0_override support harmonic-count changes by truncating or zero-padding higher modes.","category":"section"},{"location":"api/solve/#Auto-Harmonic-Selector","page":"Solve","title":"Auto Harmonic Selector","text":"When solve(...; max_harmonic=:auto) is used, the code computes\n\ngamma_mathrmtot = gamma_mathrmmr + gamma_mathrmmc\n\nthen selects M using a conservative logarithmic rule:\n\n\\gamma_tot <= 0: M = max_harmonic_auto\n\\gamma_tot >= 300: M = min_harmonic\notherwise: logarithmic interpolation using log1p(gamma_tot), rounded up to an integer\n\nSo with default settings (min_harmonic=4, max_harmonic_auto=100):\n\n(\\gamma_mr, \\gamma_mc) = (0, 0) gives M = 100\n(\\gamma_mr, \\gamma_mc) = (0, 100) gives M = 23\n(\\gamma_mr, \\gamma_mc) = (0, 300) gives M = 4\n\nYou can tune the range through SolveParams(min_harmonic=..., max_harmonic_auto=...) without changing the solve workflow.","category":"section"},{"location":"api/solve/#FermiHarmonics.SolveParams","page":"Solve","title":"FermiHarmonics.SolveParams","text":"SolveParams\n\nTyped configuration for solve.\n\nFields:\n\nmax_harmonic::Int=60: default fixed harmonic cutoff used when solve(...; max_harmonic=...) is not provided.\nmin_harmonic::Int=4: lower bound for auto harmonic estimation.\nmax_harmonic_auto::Int=100: upper bound for auto harmonic estimation.\npolydeg::Int=3: DGSEM polynomial degree.\ntspan_end::Float64=100.0: final integration time.\nresidual_tol::Float64=1e-5: steady-state absolute tolerance.\ncfl::Float64=0.8: CFL number for timestep control.\nlog_every::Int=500: monitor/visualization logging interval (accepted steps).\n\n\n\n\n\n","category":"type"},{"location":"api/solve/#FermiHarmonics.estimate_max_harmonic","page":"Solve","title":"FermiHarmonics.estimate_max_harmonic","text":"estimate_max_harmonic(gamma_mr, gamma_mc; min_harmonic=4, max_harmonic=100)\n\nEstimate an efficient harmonic cutoff from physical scattering rates.\n\nThe estimate uses the total scattering rate gamma_total = gamma_mr + gamma_mc and logarithmically interpolates:\n\ngamma_total = 0 -> max_harmonic,\ngamma_total >= 300 -> min_harmonic,\nintermediate values map via log1p(gamma_total) between those endpoints.\n\n\n\n\n\n","category":"function"},{"location":"api/solve/#FermiHarmonics.solve","page":"Solve","title":"FermiHarmonics.solve","text":"solve(mesh_path::AbstractString, boundary_conditions::Dict{Symbol, Any},\n      params, gamma_mr::Real, gamma_mc::Real; kwargs...)\n\nSolve one FermiHarmonics case.\n\nArguments:\n\nmesh_path: path to mesh input file.\nboundary_conditions: boundary-condition map used by Trixi.\nparams: solver configuration, as SolveParams.\ngamma_mr, gamma_mc: physical scattering rates.\n\nKeywords:\n\nmax_harmonic: harmonic cutoff. Use :auto (default) to estimate from gamma_mr, gamma_mc, or pass an integer for a fixed cutoff (nvars = 1 + 2*max_harmonic).\nu0_override: optional warm-start state vector.\nvisualize: enable live visualization callback.\nname: run name used in logs/visualization filenames.\n\nReturns:\n\n(sol, semi): Trixi time-integration solution and semidiscretization.\n\n\n\n\n\n","category":"function"},{"location":"api/io_utils/#I/O-Utilities","page":"I/O Utilities","title":"I/O Utilities","text":"","category":"section"},{"location":"api/io_utils/#Analysis-Output","page":"I/O Utilities","title":"Analysis Output","text":"","category":"section"},{"location":"api/io_utils/#Solution-Output","page":"I/O Utilities","title":"Solution Output","text":"","category":"section"},{"location":"api/io_utils/#FermiHarmonics.save_for_analysis","page":"I/O Utilities","title":"FermiHarmonics.save_for_analysis","text":"save_for_analysis(sol, semi, filename; nvisnodes=400)\n\nSave a0, a1, b1 observables on a uniform Cartesian grid in a lightweight HDF5 format for post-processing and analysis.  The grid is determined from the simulation domain bounds.\n\nArguments:\n\nsol: time integration solution.\nsemi: semidiscretization object.\nfilename: output HDF5 path.\nnvisnodes: number of nodes per axis of uniform sampling grid.\n\nReturns:\n\nfilename::AbstractString.\n\n\n\n\n\n","category":"function"},{"location":"api/io_utils/#FermiHarmonics.save_observables_for_python","page":"I/O Utilities","title":"FermiHarmonics.save_observables_for_python","text":"Deprecated alias for save_for_analysis.\n\n\n\n\n\n","category":"function"},{"location":"api/io_utils/#FermiHarmonics.save_solution_custom","page":"I/O Utilities","title":"FermiHarmonics.save_solution_custom","text":"save_solution_custom(sol, semi, filename; variable_names=nothing)\n\nSave solution to HDF5 file with custom filename. Restart-compatible with Trixi. Always saves conservative variables (no transformations). Use variable_names to save a subset for lightweight analysis (not restart-compatible).\n\nArguments:\n\nsol: time integration solution.\nsemi: semidiscretization object.\nfilename: output HDF5 path.\nvariable_names: optional subset of variable names to save.\n\nReturns:\n\nfilename::AbstractString.\n\n\n\n\n\n","category":"function"},{"location":"api/equations/#Equations","page":"Equations","title":"Equations","text":"We have implemented a custom equations type for use with Trixi. This offers a more fine-tuned way to run simulations that does not go through the FermiHarmonics.solve() function.","category":"section"},{"location":"api/equations/#Type","page":"Equations","title":"Type","text":"","category":"section"},{"location":"api/equations/#Constructor","page":"Equations","title":"Constructor","text":"","category":"section"},{"location":"api/equations/#Script-Style-Usage","page":"Equations","title":"Script-Style Usage","text":"params = SolveParams(;\n    max_harmonic = 60,\n    # ... other solver settings\n)\n\nnvars = 1 + 2 * params.max_harmonic\nequations = FermiHarmonics2D(\n    nvars;\n    gamma_mr = 0.05,\n    gamma_mc = 0.4,\n    max_harmonic = params.max_harmonic,\n)\n\nUse :auto at solve-time, e.g. solve(...; max_harmonic=:auto).","category":"section"},{"location":"api/equations/#FermiHarmonics.FermiHarmonics2D","page":"Equations","title":"FermiHarmonics.FermiHarmonics2D","text":"FermiHarmonics2D{NVARS} <: Trixi.AbstractEquations{2, NVARS}\n\nLinearized 2D Boltzmann system in harmonic form:\n\npartial_t u + A_x partial_x u + A_y partial_y u = S(ugamma_mrgamma_mc)\n\n\n\n\n\n","category":"type"},{"location":"api/equations/#FermiHarmonics.FermiHarmonics2D-Tuple{Integer}","page":"Equations","title":"FermiHarmonics.FermiHarmonics2D","text":"FermiHarmonics2D(nvars; gamma_mr, gamma_mc, max_harmonic=0)\n\nConstruct FermiHarmonics2D.\n\nParameters:\n\nnvars: number of state variables, must be odd (1 + 2M).\ngamma_mr: momentum-relaxing scattering rate.\ngamma_mc: momentum-conserving scattering rate.\nmax_harmonic: optional explicit harmonic cutoff; if set, must satisfy nvars == 1 + 2*max_harmonic.\n\nReturns:\n\nFermiHarmonics2D{nvars} equations object.\n\n\n\n\n\n","category":"method"},{"location":"#FermiHarmonics","page":"Home","title":"FermiHarmonics","text":"This is a Julia code for simulating a toy model of Fermi liquid transport with momentum relaxing and momentum conserving collisions.  I use Trixi.jl which is a library for high-accuracy PDE solutions.","category":"section"},{"location":"#Model-Details","page":"Home","title":"Model Details","text":"We solve a linearized Boltzmann equation:\n\npartial_t phi + v_F(costhetapartial_x+sinthetapartial_y)phi\n= mathcalCphi\n\nThe right hand side is the collision integral, featuring physical terms designed to mitigate Gibbs phenomena. We approximate the distribution function \\phi as a Fourier series with maximum harmonic M:\n\nphi(xythetat)=fraca_02+sum_m=1^Mlefta_mcos(mtheta)+b_msin(mtheta)right\n\nBy default, we adaptively pick M based on how strong the damping is from collisions. The minimum M is 4 and the maximum M is 100. This way, simulations in high damping regimes use fewer harmonics, while weakly damped cases keep higher angular resolution.\n\nWe adopt a relaxation-time-like (BGK) approximation for the collision integral, so that the Boltzmann equation in Harmonic basis reads, for m=0\n\npartial_t a_0 + v_Fleft(partial_x a_1 + partial_y b_1right) = -gamma_0 a_0\n\nand for m ge 1\n\npartial_t a_m\n + fracv_F2partial_x(a_m-1 + a_m+1)\n + fracv_F2partial_y(b_m+1 - b_m-1)\n = -gamma_m a_m\n\npartial_t b_m\n + fracv_F2partial_x(b_m-1 + b_m+1)\n + fracv_F2partial_y(a_m-1 - a_m+1)\n = -gamma_m b_m\n\nFor the scattering rates, we adopt a two-time (linearized BGK) model to capture the ballistic-hydrodynamic-diffusive crossover, \n\ngamma_0 = 0\n\ngamma_1 = gamma_mathrmmr\n\ngamma_n = gamma_mathrmmr + gamma_mathrmmc (n ge 2)\n\nIn this code release, source terms are purely physical; we do not apply additional numerical tail damping.","category":"section"},{"location":"#Solve-Entry-Point","page":"Home","title":"Solve Entry Point","text":"The main solve interface is documented in:\n\nSolve API\nMesh Guide","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using FermiHarmonics\nusing Trixi  # for boundary condition constructors\n\nboundary_conditions = Dict(\n    :walls => MaxwellWallBC(1.0),\n    :contact_top => OhmicContactBC(-0.5),\n    :contact_bottom => OhmicContactBC(0.5),\n)\n\nparams = SolveParams(;\n    polydeg = 3,\n    cfl = 0.8,\n    tspan_end = 50.0,\n    residual_tol = 1e-5,\n    log_every = 200,\n    min_harmonic = 4,\n    max_harmonic_auto = 100,\n)\n\nsol, semi = solve(\n    \"projects/square_bells_ucsb/mesh/square_bells.inp\",\n    boundary_conditions,\n    params,\n    0.0,   # gamma_mr\n    50.0;  # gamma_mc\n    max_harmonic = :auto,\n    visualize = false,\n    name = \"quick_start\",\n)","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"Pages = [\n    \"api/equations.md\",\n    \"api/boundary_conditions.md\",\n    \"api/source_terms.md\",\n    \"api/io_utils.md\",\n    \"api/solve.md\",\n    \"api/slurm_utils.md\",\n]\nDepth = 2","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"api/boundary_conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"api/boundary_conditions/#Boundary-Condition-Types","page":"Boundary Conditions","title":"Boundary Condition Types","text":"We implement two types of boundary condition.","category":"section"},{"location":"api/boundary_conditions/#Projectors","page":"Boundary Conditions","title":"Projectors","text":"","category":"section"},{"location":"api/boundary_conditions/#FermiHarmonics.MaxwellWallBC","page":"Boundary Conditions","title":"FermiHarmonics.MaxwellWallBC","text":"MaxwellWallBC(p_scatter; tol=0.0)\n\nWall boundary condition with diffuse/specular mixing. It blends between them with parameter p_scatter. The physics of the diffuse case is that particles scatter from the wall at a random angle with an isotropic distribution, while the specular case is that particles reflect with the same angle they arrived at. The blended target state is then projected onto the incoming characteristics to get the final BC state.\n\nParameters:\n\np_scatter: diffuse fraction (1.0 fully diffuse, 0.0 fully specular)\ntol: eigenvalue tolerance for incoming-mode projector construction\n\nReturns:\n\nMaxwellWallBC.\n\n\n\n\n\n","category":"type"},{"location":"api/boundary_conditions/#FermiHarmonics.OhmicContactBC","page":"Boundary Conditions","title":"FermiHarmonics.OhmicContactBC","text":"OhmicContactBC(bias; p_ohmic_absorb=1.0, tol=0.0)\n\nThis one is meant to model connection to an ohmic contact with fixed potential (or fixed a0, in our case.) Ohmic contact boundary condition with fixed monopole value (a0 = bias).  The physics of the absorbing case is that particles are absorbed at the contact and re-emitted with a distribution corresponding to the imposed bias (fixed value of only a0, with higher harmonics determined by diffuse scattering). The specular case is that particles reflect with the same angle they arrived at, with no bias. The blended target state is then projected onto the incoming modes to get the final BC state.  Note that this means in the case pohmicabsorb = 0, we no longer have any particles being injected.\n\nParameters:\n\nbias: imposed contact value for the monopole mode\np_ohmic_absorb: absorption fraction (1.0 fully absorbing, 0.0 fully specular)\ntol: eigenvalue tolerance for incoming-mode projector construction\n\nReturns:\n\nOhmicContactBC.\n\n\n\n\n\n","category":"type"},{"location":"api/boundary_conditions/#FermiHarmonics.incoming_projector","page":"Boundary Conditions","title":"FermiHarmonics.incoming_projector","text":"incoming_projector(Ax, Ay, unit_normal; tol=0.0) -> SparseMatrixCSC{Float64}\n\nCompute incoming projector for flux Jacobian A = Axnx + Ayny as sparse matrix. Incoming modes are eigenvectors with eigenvalues <= -tol.\n\n\n\n\n\n","category":"function"},{"location":"api/slurm_utils/#SLURM-Utilities-API","page":"SLURM Utilities","title":"SLURM Utilities API","text":"","category":"section"},{"location":"api/slurm_utils/#Behavior-Notes","page":"SLURM Utilities","title":"Behavior Notes","text":"submit_sweep! returns a Cmd only in dry_run=true; otherwise it submits and returns nothing.\nwrite_sweep_metadata! writes/overwrites sweep_metadata.toml.\nselect_cases uses SLURM_ARRAY_TASK_ID from environment and defaults to task 1 if unset.","category":"section"},{"location":"api/slurm_utils/#FermiHarmonics.submit_sweep!","page":"SLURM Utilities","title":"FermiHarmonics.submit_sweep!","text":"submit_sweep!(; \n              script, \n              n_jobs, \n              project_dir=pwd(), \n              julia_cmd=\"julia\", \n              script_args=String[], \n              env=Dict(), \n              sbatch=Dict(), \n              array=nothing, \n              dry_run=false)\n\nSubmit a SLURM array job to run a parameter sweep. The script will be executed with julia_cmd and --project=project_dir. The sbatch dict can include any additional SLURM options (e.g. :time => \"01:00:00\").  If array is provided, it will override the default array specification of 1-n_jobs. If dry_run is true, the  constructed Cmd is returned without submission. Otherwise, the job is submitted and the function returns nothing.\n\nReturns:\n\nCmd when dry_run=true.\nnothing when submitted.\n\n\n\n\n\n","category":"function"},{"location":"api/slurm_utils/#FermiHarmonics.write_sweep_metadata!","page":"SLURM Utilities","title":"FermiHarmonics.write_sweep_metadata!","text":"write_sweep_metadata!(data_dir::AbstractString, \n                      params, sweep_metadata, slurm_metadata,\n                      gamma_mr_vals, gamma_mc_vals)\n\nWrite sweep metadata to sweep_metadata.toml.\n\nReturns:\n\nmetadata_path::String: path to written TOML file.\n\n\n\n\n\n","category":"function"},{"location":"api/slurm_utils/#FermiHarmonics.archive_mesh!","page":"SLURM Utilities","title":"FermiHarmonics.archive_mesh!","text":"archive_mesh!(mesh_path::AbstractString, data_dir::AbstractString)\n\nCopy the mesh file to the sweep data directory for reproducibility.\n\nReturns:\n\narchive_path::String: destination path of archived mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/slurm_utils/#FermiHarmonics.copy_mesh_to_scratch","page":"SLURM Utilities","title":"FermiHarmonics.copy_mesh_to_scratch","text":"copy_mesh_to_scratch(mesh_path::AbstractString, prefix::AbstractString)\n\nCopy the mesh file to a scratch directory on the compute node and return the local path. This is done so that we  avoid data races when many jobs are trying to load the meshes a bunch of times.\n\nReturns:\n\nlocal_path::String: copied mesh path in scratch space.\n\n\n\n\n\n","category":"function"},{"location":"api/slurm_utils/#FermiHarmonics.select_cases","page":"SLURM Utilities","title":"FermiHarmonics.select_cases","text":"select_cases(gamma_mr_vals, gamma_mc_vals; cases_per_task::Int, env::AbstractDict=ENV)\n\nDetermine which cases to run for the current task based on the total parameter grid and the SLURMARRAYTASK_ID. \n\nReturns:\n\n(case_indices, total_cases, n_cases_this_task, task_id).\n\n\n\n\n\n","category":"function"},{"location":"api/slurm_utils/#FermiHarmonics.grid_lookup","page":"SLURM Utilities","title":"FermiHarmonics.grid_lookup","text":"grid_lookup(gamma_mr_vals, gamma_mc_vals, index_global::Int)\n\nGiven a global case index, look up the corresponding gammamr and gammamc values from the parameter grid. Assumes the  grid is ordered with gamma_mc varying fastest.\n\nReturns:\n\n(gamma_mr, gamma_mc) for index_global.\n\n\n\n\n\n","category":"function"}]
}
